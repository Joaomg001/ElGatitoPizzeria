<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> ElGatitoPizzeria </title>

    <link rel="stylesheet" href="style.css">

    <script type="importmap">
        {
          "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
          }
        }
      </script>

    <script type="module">

        import * as THREE from "three";

        import { ConvexGeometry } from "three/addons/geometries/ConvexGeometry.js";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";

        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

        // To store the scene graph, and elements usefull to rendering the scene
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,  // NEW
            renderer: null,
        };

        // HELPER FUNCTIONS

        const helper = {

            initEmptyScene: function (sceneElements) {

                // Create the 3D scene
                sceneElements.sceneGraph = new THREE.Scene();

                // Add camera
                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 500);
                sceneElements.camera = camera;

                // Illumination
                // Add ambient light
                const ambientLight = new THREE.AmbientLight('rgb(255, 255, 255)', 0.2);
                sceneElements.sceneGraph.add(ambientLight);

                // Add spotlight (with shadows)
                const light_1 = new THREE.SpotLight('rgb(255, 255, 255)', 25);
                light_1.decay = 1;
                light_1.position.set(-5, 8, 0);
                sceneElements.sceneGraph.add(light_1);

                // Setup shadow properties for the spotlight
                light_1.castShadow = true;
                light_1.shadow.mapSize.width = 2048;
                light_1.shadow.mapSize.height = 2048;

                // Give a name to the spot light
                light_1.name = "light 1";

                // Create renderer (with shadow map)
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor('rgb(255, 255, 150)', 1.0);
                renderer.setSize(width, height);

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Add the rendered image in the HTML DOM
                const htmlElement = document.querySelector("#ElGatitoPizzeria");
                htmlElement.appendChild(renderer.domElement);

                //Control for the camera
                sceneElements.control = new OrbitControls(camera, renderer.domElement);
                sceneElements.control.screenSpacePanning = true;

            },

            render: function (sceneElements) {
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            },
        };

        const cubes = [];

        // Function to generate random color cubes (foods)
        function generateRandomCubeColor(sceneGraph, index){
            const randomColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const cubeGeometry = new THREE.BoxGeometry(0.5,0.5,0.5);
            const cubeMaterial = new THREE.MeshPhongMaterial({ color: randomColor });
            const cube = new THREE.Mesh(cubeGeometry,cubeMaterial);
            const spacing = 1;
            cube.position.set(index-2, 0.5, -5.2);

            cube.castShadow = true;
            cube.receiveShadow = true;

            sceneGraph.add(cube);

            cubes.push(cube);
        }

        // Function to change the color of all cubes
        function updateCubeColors() {
            cubes.forEach((cube) => {
                const newColor = new THREE.Color(Math.random(), Math.random(), Math.random());
                cube.material.color = newColor; // Update the cube's color
            });
        }
        
        setInterval(updateCubeColors, 2000);
        
        const costumers = [];

        // Function to generate customer
        function generateRandomCustomer(sceneGraph,index){
            const colors = ["#a88532", "#a85532", "#000000", "#ffffff", "#253745"];
            const loader = new GLTFLoader();
            loader.load(
                'Kitten.glb',
                function (gltf) {
                    const costumer = gltf.scene;

                    costumer.position.set(index-2,0.5,-5.8);
                    costumer.scale.set(0.1,0.1,0.1);
                    costumer.rotation.y = -Math.PI/2;

                    // pick random color from array colors
                    const randomColor = colors[Math.floor(Math.random() * colors.length)];

                    costumer.traverse(function (node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;

                        // Assign a random color to the kitten
                        node.material.color.set(randomColor);
                    }
                });

                // Add the kitten to the scene
                sceneGraph.add(costumer);

                // Store the kitten in the array for later updates
                costumers.push(costumer);
            },
            undefined,
            function (error) {
                console.error('An error occurred while loading the kitten model:', error);
            }
            )
        }


        // FUCNTIONS FOR BUILDING THE SCENE

        const scene = {

            // Create and insert in the scene graph the models of the 3D scene

            load3DObjects: function (sceneGraph) {
                
                // generate cubes of food
                for (let i = 0; i < 5; i++) {
                    generateRandomCubeColor(sceneGraph, i);
                    generateRandomCustomer(sceneGraph,i);
                }

                // Create a cube to hold
                const TestGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const TestMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(0,255,255)' });
                const Test = new THREE.Mesh(TestGeometry, TestMaterial);
                Test.position.set(1, 0.5, 3);
                Test.name = "testCube"; // Name the test cube for reference
                sceneGraph.add(Test);

                // Add bounding box for the test cube
                testCubeBB = new THREE.Box3().setFromObject(Test);
                testCubeHelper = new THREE.Box3Helper(testCubeBB, 0xff0000); // Red bounding box
                sceneGraph.add(testCubeHelper);

                // Create a ground plane
                const planeGeometry = new THREE.PlaneGeometry(6, 10);
                const planeMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(200, 200, 200)', side: THREE.DoubleSide });
                const planeObject = new THREE.Mesh(planeGeometry, planeMaterial);
                sceneGraph.add(planeObject);

                // Change orientation of the plane using rotation
                planeObject.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
                // Set shadow property
                planeObject.receiveShadow = true;

                // Create a kitten
                const loader = new GLTFLoader();
                loader.load(
                    'Kitten.glb',
                    function (gltf) {
                        const kitten = gltf.scene;

                        // Set position
                        kitten.position.set(0, 0, 0);

                        // Set scale
                        kitten.scale.set(0.1, 0.1, 0.1);

                        // Enable shadows for the model
                        kitten.traverse(function (node) {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });

                        // Add the model to the scene
                        sceneGraph.add(kitten);

                        // Name the model for later reference
                        kitten.name = "kitten";

                        // Create a bounding box for the kitten
                        kittenBB = new THREE.Box3().setFromObject(kitten);
                        kittenHelper = new THREE.Box3Helper(kittenBB, 0x00ff00); // Green bounding box
                        sceneGraph.add(kittenHelper);
                    },
                    undefined,
                    function (error) {
                        console.error('An error occurred while loading the model:', error);
                    }
                );

                // Create a table
                const BoxGeometry = new THREE.BoxGeometry(6, 0.5, 1);
                const BoxMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(200,255,150)' });
                const table = new THREE.Mesh(BoxGeometry, BoxMaterial);
                sceneGraph.add(table);

                // Set position of the cylinder
                // Move to the right and towards the camera
                // The base of the cylinder is on the plane
                table.translateX(0).translateY(0).translateZ(-5.2);

                // Set shadow property
                table.castShadow = true;
                
                // add another table
                const table2 = new THREE.Mesh(BoxGeometry,BoxMaterial);
                sceneGraph.add(table2);
                table2.translateX(0).translateY(0).translateZ(5.3);

                // NEW - Create a CONVEX HULL

                const vertices = []

                vertices.push(new THREE.Vector3(-1, 0, 1));
                vertices.push(new THREE.Vector3(0, 0, 1));
                vertices.push(new THREE.Vector3(0, 0, 2));
                vertices.push(new THREE.Vector3(-1, 0, 2));
                vertices.push(new THREE.Vector3(-0.5, 2.5, 1.5));

                const meshMaterial = new THREE.MeshLambertMaterial({
                    color: 0xffffff,
                    opacity: 0.5,
                    transparent: true
                });

                const meshGeometry = new ConvexGeometry(vertices);
                const convexHull = new THREE.Mesh(meshGeometry, meshMaterial);
                sceneGraph.add(convexHull);

                convexHull.castShadow = true;
            }
        };

        // ANIMATION
        //To keep track of the keyboard - WASD
        var kittenSpeed = 0.05;
        var keyD = false, keyA = false, keyS = false, keyW = false, keySpace = false;
        const cameraOffset = new THREE.Vector3(0, 10, 10);
        // bounding boxes
        let testCubeBB, testCubeHelper;
        let kittenBB, kittenHelper;

        function computeFrame(time) {
            // CONTROLING THE kitten WITH THE KEYBOARD
            const kitten = sceneElements.sceneGraph.getObjectByName("kitten");
            const testCube = sceneElements.sceneGraph.getObjectByName("testCube");

            if (kitten) { // Check if the kitten object is loaded
                
                if (keyD){
                    kitten.rotation.y = 0;  // face right
                    if(kitten.position.x <= 2.5)
                            kitten.translateX(kittenSpeed);
                }
                if (keyW) {
                    kitten.rotation.y = Math.PI / 2; // face forward
                    if(kitten.position.z >= -4.5)
                        kitten.translateX(kittenSpeed);
                }
                if (keyA) {
                    kitten.rotation.y = -Math.PI;   // face left
                    if(kitten.position.x >= -2.5)
                        kitten.translateX(kittenSpeed);
                }
                if (keyS) {
                    kitten.rotation.y = -Math.PI / 2;   // face back
                    if(kitten.position.z <= 4.5)
                        kitten.translateX(kittenSpeed);
                }

                // Update kitten bounding box
                kittenBB.setFromObject(kitten);
                kittenBB.expandByScalar(0.2);
                kittenHelper.updateMatrixWorld(true);
            }

            // Update test cube bounding box
            if (testCube) {
                // Update test cube bounding box
                testCubeBB.setFromObject(testCube);
                testCubeBB.expandByScalar(0.2);
                testCubeHelper.updateMatrixWorld(true);

                // Check for intersection
                if (kitten && kittenBB.intersectsBox(testCubeBB) && keySpace) {
                    const forward = new THREE.Vector3(1, 0.5, 0);
                    forward.applyQuaternion(kitten.quaternion); // Rotate forward vector by kitten's rotation
                    forward.normalize();

                    const offset = forward;
                    testCube.position.copy(kitten.position.clone().add(offset));

                }
            }


            // Camera follows the kitten
            if (kitten) {
                const kittenPosition = kitten.position.clone();
                const cameraPosition = kittenPosition.add(cameraOffset);

                sceneElements.camera.position.copy(cameraPosition);
                sceneElements.camera.lookAt(kitten.position);
            }

            // Rendering
            helper.render(sceneElements);

            // NEW --- Update control of the camera
            sceneElements.control.update();

            // Animation
            // Call for the next frame
            requestAnimationFrame(computeFrame);
        }

        // Call functions:
        //  1. Initialize the empty scene
        //  2. Add elements within the scene
        //  3. Animate

        function init() {
            helper.initEmptyScene(sceneElements);
            scene.load3DObjects(sceneElements.sceneGraph);
            requestAnimationFrame(computeFrame);
        }

        // HANDLING EVENTS

        // Event Listeners

        window.addEventListener('resize', resizeWindow);

        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);

        // Update render image size and camera aspect when the window is resized
        function resizeWindow(eventParam) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();

            sceneElements.renderer.setSize(width, height);

            // Comment when doing animation
            // computeFrame(sceneElements);
        }

        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = true;
                    break;
                case 83: //s
                    keyS = true;
                    break;
                case 65: //a
                    keyA = true;
                    break;
                case 87: //w
                    keyW = true;
                    break;
                case 32: //space
                    if(keySpace == false)
                        keySpace = true;
                    else
                        keySpace = false;
                    break;
            }
        }

        function onDocumentKeyUp(event) {
            switch (event.keyCode) {
                case 68: //d
                    keyD = false;
                    break;
                case 83: //s
                    keyS = false;
                    break;
                case 65: //a
                    keyA = false;
                    break;
                case 87: //w
                    keyW = false;
                    break;
            }
        }

        // STARTING

        init();

    </script>

</head>

<body>
    <div id="ElGatitoPizzeria"> </div>
</body>

</html>