<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> ElGatitoPizzeria </title>

    <link rel="stylesheet" href="style.css">

    <script type="importmap">
        {
          "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
          }
        }
      </script>

    <script type="module">

        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

        // To store the scene graph, and elements usefull to rendering the scene
        const sceneElements = {
            sceneGraph: null,
            camera: null,
            control: null,
            renderer: null,
        };

        ///////////////////////////////////////////////////////////////////////
        // Loading Manager
        ///////////////////////////////////////////////////////////////////////
        const loadingManager = new THREE.LoadingManager();
        let loadingScreenShownOnce = false; // Add this near your other global variables

        // Update loadingManager.onStart and onLoad:
        loadingManager.onStart = function () {
            if (!loadingScreenShownOnce) {
                document.getElementById('loadingScreen').style.display = 'flex';
                document.getElementById('loadingProgress').textContent = '0%';
            }
        };

        loadingManager.onLoad = function () {
            if (!loadingScreenShownOnce) {
                document.getElementById('loadingScreen').style.display = 'none';
                loadingScreenShownOnce = true;
            }
            if (gameStart) {
                requestAnimationFrame(computeFrame);
            }
        };

        loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
            const progress = (itemsLoaded / itemsTotal) * 100;
            document.getElementById('loadingProgress').textContent = `${Math.round(progress)}%`;
        };

        
        ///////////////////////////////////////////////////////////////////////
        // Vaiables
        ///////////////////////////////////////////////////////////////////////
        const loader = new GLTFLoader(loadingManager);
        const textureLoader = new THREE.TextureLoader(loadingManager);
        let  customerGLTF = null;

        const customers = [];
        const pizzasA = [];
        const pizzasCustomer = [];
        const cars = [];
        let pizzaBB, pizzaHelper;
        let kittenBB, kittenHelper;

        const customerColors = ["#a88532", "#a85532", "#000000", "#ffffff", "#253745"];
        const carLanes = [-14, -12];
        const carSpeedRange = [10, 14];
        let kittenSpeed = 10;
        const cameraOffset = new THREE.Vector3(0, 10, 10);

        let score = 0;
        let gameStart = false;
        let gameEnded = false;
        let heldPizza = null;
        let heldPizzaBB = null;
        let lastButtonPress = 0;
        let lastTime = performance.now();

        let keyD = false, keyA = false, keyS = false, keyW = false, keyE = false, keySpace = false;

        let startTime;
        let timerInterval;
        let elapsedSeconds = 0;

        // Hints variables
        let currentHintIndex = 0;
        const hints = [
            "Hold SpaceBar to pick up pizzas.",
            "Deliver the right pizza to the right customer.",
            "Use W, A, S, D to move.",
            "When close to the bell press E to reset the pizzas.",
            "Try to deliver pizzas before time runs out! (2 minutes)"
        ];

        ///////////////////////////////////////////////////////////////////////
        // HELPER FUNCTIONS
        ///////////////////////////////////////////////////////////////////////
        const helper = {

            initEmptyScene: function (sceneElements) {

                // Create the 3D scene
                sceneElements.sceneGraph = new THREE.Scene();

                // Add camera
                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 500);
                sceneElements.camera = camera;

                // Illumination
                // Add ambient light
                const ambientLight = new THREE.AmbientLight('rgb(255, 255, 255)', 0.2);
                sceneElements.sceneGraph.add(ambientLight);

                // Add spotlight (with shadows)
                const light_1 = new THREE.SpotLight('rgb(172,172,193)', 5);
                light_1.decay = 1;
                light_1.position.set(-18, 22, 0);
                sceneElements.sceneGraph.add(light_1);

                // Setup shadow properties for the spotlight
                light_1.castShadow = true;
                light_1.shadow.mapSize.width = 2048;
                light_1.shadow.mapSize.height = 2048;

                // Give a name to the spot light
                light_1.name = "light 1";
                light_1.target.position.set(0, 0, 0);
                sceneElements.sceneGraph.add(light_1.target);
                
                // Create renderer (with shadow map)
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                sceneElements.renderer = renderer;
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor('rgb(84,107,171)', 1);
                renderer.setSize(width, height);

                // Setup shadowMap property
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Add the rendered image in the HTML DOM
                const htmlElement = document.querySelector("#ElGatitoPizzeria");
                htmlElement.appendChild(renderer.domElement);

                // Control for the camera
                sceneElements.control = new OrbitControls(camera, renderer.domElement);
                sceneElements.control.screenSpacePanning = true;

            },

            render: function (sceneElements) {
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
            },
        };


        ///////////////////////////////////////////////////////////////////////
        // Function to generate customer
        ///////////////////////////////////////////////////////////////////////

        let belongsToCustomer = false;
        function generateRandomCustomer(sceneGraph, index, position) {
        function addCustomerToScene(customer, sceneGraph, index, position, color) {
            if (position) {
                customer.position.copy(position);
                customer.position.z = -5.8;
            } else {
                customer.position.set(index * 1.5 - 3, 0.5, -5.8);
            }
            customer.scale.set(0.1, 0.1, 0.1);
            customer.rotation.y = -Math.PI / 2;

            customer.traverse(function (node) {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                    node.material = node.material.clone();
                    node.material.color.set(color);
                }
            });

            sceneGraph.add(customer);
            customers[index] = customer;

            createPizza(sceneGraph, index, true, customer.position);
        }
            // New random customer color
            const randomColor = customerColors[Math.floor(Math.random() * customerColors.length)];
            customers[index + "_color"] = randomColor;

            if (customerGLTF) {
                // Clone model
                const customer = customerGLTF.clone(true);
                addCustomerToScene(customer, sceneGraph, index, position, randomColor);
            } else {
                customerLoader.load(
                    'Kitten.glb',
                    function (gltf) {
                        const customer = gltf.scene;
                        addCustomerToScene(customer, sceneGraph, index, position, randomColor);
                    },
                    undefined,
                    function (error) {
                        console.error('An error occurred while loading the kitten model:', error);
                    }
                );
            }
        }

        ///////////////////////////////////////////////////////////////////////
        // CREATING PIZZAS
        ///////////////////////////////////////////////////////////////////////
        
        function createPizza(sceneGraph,index,belongsToCustomer, position = null) {
            const scale = 0.2;
            const randomPizza = Math.floor(Math.random()*5) // 5 different types
            let toppingColor, toppingType;
            let toppingFlag = false;
            let pizzaType = -1;

            switch(randomPizza){
                case 0: // Cheese
                    toppingFlag = false;
                    pizzaType = 0;
                    break;
                case 1: // Pepperoni
                    toppingFlag = true;
                    toppingType = 0;
                    toppingColor = 'rgb(210, 43, 43)';
                    pizzaType = 1;
                    break;
                case 2: // Olives
                    toppingFlag = true;
                    toppingType = 0;
                    toppingColor = 'rgb(0,0,0)';
                    pizzaType = 2;
                    break;
                case 3: // Bacon
                    toppingFlag = true;
                    toppingType = 1;
                    toppingColor = 'rgb(240,128,128)';
                    pizzaType = 3;
                    break;
                case 4: // Peppers
                    toppingFlag = true;
                    toppingType = 1;
                    toppingColor = 'rgb(0,128,0)';
                    pizzaType = 4;
                    break;           
            }
            
            // Create the pizza base
            const pizzaGroup = new THREE.Group();

            pizzaGroup.userData.pizzaType = pizzaType;
            
            const pizzaBaseGeometry = new THREE.CylinderGeometry(2.1*scale,2.1*scale,0.05*scale, 32);
            const pizzaBaseMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(238, 192, 123)'});
            const pizzaBase = new THREE.Mesh(pizzaBaseGeometry, pizzaBaseMaterial);
            pizzaBase.position.set(0, 0.1*scale, 0);
            pizzaBase.receiveShadow = true;
            pizzaBase.castShadow = true;
            pizzaGroup.add(pizzaBase);

            const plateGeometry = new THREE.CylinderGeometry(2.2*scale,2.2*scale,0.05*scale, 32);
            const plateMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)'});
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0.05*scale, -0.1*scale, 0);
            plate.receiveShadow = true;
            plate.castShadow = true;
            pizzaGroup.add(plate);

            // Create cheese
            const cheeseGeometry = new THREE.CircleGeometry(1.8*scale, 32);
            const cheeseMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(247, 223, 71)'});
            const cheese = new THREE.Mesh(cheeseGeometry, cheeseMaterial);
            cheese.rotation.x = -Math.PI / 2;
            cheese.position.set(0, 0.15*scale, 0);
            cheese.receiveShadow = true;
            pizzaGroup.add(cheese);
            
            // Create toppings
            if(toppingFlag == true && toppingType == 0){
                const toppingGeometry = new THREE.CircleGeometry(0.2*scale, 16);
                const toppingMaterial = new THREE.MeshPhongMaterial({ color: toppingColor});

                const toppingPositions = [
                    { x: 0.5*scale, z: 0.5*scale },
                    { x: -0.5*scale, z: 0.5*scale },
                    { x: 0.5*scale, z: -0.5*scale },
                    { x: -0.5*scale, z: -0.5*scale },
                    { x: 0, z: 0 },
                    { x: 1*scale, z: 1*scale },
                    { x: -1*scale, z: 1*scale },
                    { x: 1*scale, z: -1*scale },
                    { x: -1*scale, z: -1*scale },
                    { x: 0, z: 1*scale },
                    { x: 0, z: -1*scale },
                    { x: 1*scale, z: 0 },
                    { x: -1*scale, z: 0 }
                ];

                toppingPositions.forEach((pos) => {
                    const topping = new THREE.Mesh(toppingGeometry, toppingMaterial);
                    topping.rotation.x = -Math.PI / 2; 
                    topping.position.set(pos.x, 0.2*scale, pos.z);
                    pizzaGroup.add(topping);
                });
            }

            if(toppingFlag == true && toppingType == 1){
                const toppingGeometry = new THREE.PlaneGeometry(0.3*scale,0.9*scale);
                const toppingMaterial = new THREE.MeshPhongMaterial({color: toppingColor});

                const toppingPositions = [
                    {x: 0, z:0},
                    {x: 1*scale, z:0},
                    {x:0, z:1*scale},
                    {x: -1*scale, z:0},
                    {x:0, z:-1*scale}
                ]
                
                toppingPositions.forEach((pos) => {
                    const topping = new THREE.Mesh(toppingGeometry,toppingMaterial);
                    topping.rotation.x = -Math.PI / 2;
                    topping.rotation.z = Math.PI / 4;
                    topping.position.set(pos.x, 0.2*scale, pos.z);
                    pizzaGroup.add(topping);
                })
            }

            
            if(belongsToCustomer == false){ // Pizzas on the table
                pizzaGroup.position.set(index*1.5-3, 0.3, 5.2);
                // TESTING PIZZA
                pizzaBB = new THREE.Box3().setFromObject(pizzaGroup);
                pizzaBB.expandByScalar(0.2);
                //pizzaHelper = new THREE.Box3Helper(pizzaBB, 0xff0000); // red
                //sceneGraph.add(pizzaHelper);
                // ENDS HERE
                sceneGraph.add(pizzaGroup);
                pizzasA.push(pizzaGroup);
             }else if(belongsToCustomer == true){ // Pizzas for customers
                if (position) {
                    pizzaGroup.position.copy(position);
                    pizzaGroup.position.y = 0.3;
                    pizzaGroup.position.z = -5.2;
                } else {
                    pizzaGroup.position.set(index*1.5-3, 0.3, -5.2);
                }
                // Easy spot toppings
                pizzaGroup.traverse(function(node) {
                    if (node.isMesh) {
                        const isTopping = (
                            node.geometry.type === "CircleGeometry" ||
                            node.geometry.type === "PlaneGeometry"
                        );
                        if (isTopping) {
                            node.material.transparent = false;
                            node.material.opacity = 1.0;
                        } else {
                            node.material.transparent = true;
                            node.material.opacity = 0.5;
                        }
                    }
                });
                            sceneGraph.add(pizzaGroup);
                            pizzasCustomer[index] = pizzaGroup;
                        }
        }

        ///////////////////////////////////////////////////////////////////////
        //  CREATE A CAR
        ///////////////////////////////////////////////////////////////////////

        function createCar(direction) {
            const carGroup = new THREE.Group();

            // Car body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.5, 1);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255, 0, 0)' });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.25, 0);
            body.castShadow = true;
            body.receiveShadow = true;
            carGroup.add(body);

            const roofGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.8);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(200, 0, 0)' });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 0.55, 0);
            roof.castShadow = true;
            roof.receiveShadow = true;
            carGroup.add(roof);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.2, 32);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(50, 50, 50)' });

            const wheelPositions = [
                { x: -0.6, y: 0, z: -0.5 },
                { x: 0.6, y: 0, z: -0.5 },
                { x: -0.6, y: 0, z: 0.5 },
                { x: 0.6, y: 0, z: 0.5 },
            ];

            wheelPositions.forEach((pos) => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                wheel.receiveShadow = true;
                carGroup.add(wheel);
            });

            // Headlights
            const headlightGeometry = new THREE.CylinderGeometry(0.1,0.05, 0.2,32);
            const headlightMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255, 255, 0)' , transparent: true, opacity: 0.8, emissive: 'rgb(255, 255, 0)', emissiveIntensity: 1});
            const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            headlight.rotation.z = -Math.PI / 2;
            const headlightClone = headlight.clone();
            headlight.position.set(0.7, 0.3, 0.3);
            headlightClone.position.set(0.7, 0.3, -0.3);
            carGroup.add(headlight);
            carGroup.add(headlightClone);

            // Iluminate headlights
            const headlightSource = new THREE.SpotLight('rgb(255, 255, 0)', 15, 50);
            headlightSource.castShadow = true;
            headlightSource.angle = Math.PI / 3.5;
            headlightSource.decay = 1;
            headlightSource.position.set(0.3, 0.8, 0.3);

            // Set target
            const headlightTarget = new THREE.Object3D();
            headlightTarget.position.set(0.8, 0.8, 0.3);
            carGroup.add(headlightTarget);
            headlightSource.target = headlightTarget;

            carGroup.add(headlightSource);

            if (direction === -1) {
                carGroup.rotation.y = Math.PI;
            }

            return carGroup;
        }
        
        ///////////////////////////////////////////////////////////////////////
        // FUCNTIONS FOR BUILDING THE SCENE
        ///////////////////////////////////////////////////////////////////////

        const scene = {

            // Create and insert in the scene graph the models of the 3D scene

            load3DObjects: function (sceneGraph) {
                
                for (let i = 0; i < 5; i++) {
                    generateRandomCustomer(sceneGraph,i); // Create customers
                    createPizza(sceneGraph,i,false); // Spawn pizzas 
                }
                
                // Spawn player character (kitten)
                loader.load(
                    'Kitten.glb',
                    function (gltf) {
                        const kitten = gltf.scene;

                        kitten.position.set(0, 0, 0);

                        kitten.scale.set(0.1, 0.1, 0.1);

                        kitten.rotation.y = -Math.PI / 2; 

                        kitten.traverse(function (node) {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                            }
                        });

                        sceneGraph.add(kitten);

                        kitten.name = "kitten";

                        // Create a bounding box for the kitten
                        kittenBB = new THREE.Box3().setFromObject(kitten);
                        kittenHelper = new THREE.Box3Helper(kittenBB, 0x00ff00); // green
                        // sceneGraph.add(kittenHelper);
                    },
                    undefined,
                    function (error) {
                        console.error('An error occurred while loading the model:', error);
                    }
                );

                ///////////////////////////////////////////////////////////////////////
                //  CREATE RESTAURANT
                ///////////////////////////////////////////////////////////////////////
                // Create a texture loader

                // Create restaurant floor
                // Create floor
                const floorTexture = textureLoader.load('textures/floor.jpg');
                floorTexture.wrapS = THREE.RepeatWrapping;
                floorTexture.wrapT = THREE.RepeatWrapping;
                floorTexture.repeat.set(2, 2);
                const floorGeometry = new THREE.PlaneGeometry(10, 10);
                const floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(0, 0.01, 0);
                floor.receiveShadow = true;
                sceneGraph.add(floor);
                
                // Create wooden floor
                const woodenFloorTexture = textureLoader.load('textures/woodenFloor.jpg');
                woodenFloorTexture.wrapS = THREE.RepeatWrapping;
                woodenFloorTexture.wrapT = THREE.RepeatWrapping;
                woodenFloorTexture.repeat.set(2, 2);
                const woodenFloorGeometry = new THREE.PlaneGeometry(13, 15);
                const woodenFloorMaterial = new THREE.MeshPhongMaterial({ map: woodenFloorTexture, side: THREE.DoubleSide });
                const woodenFloor = new THREE.Mesh(woodenFloorGeometry, woodenFloorMaterial);
                woodenFloor.position.set(0, -0.15, 0);
                woodenFloor.rotation.x = -Math.PI / 2;
                sceneGraph.add(woodenFloor);
                woodenFloor.receiveShadow = true;

                // Create table
                const BoxGeometry = new THREE.BoxGeometry(10, 0.5, 1);
                const BoxMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(99,59,59)' });
                const table = new THREE.Mesh(BoxGeometry, BoxMaterial);
                const tablePositions = [
                    { x: 0, y: 0, z: -5.2, ry: 0 },
                    { x: 0, y: 0, z: 5.3, ry: 0 },
                    { x: 4.5, y: 0, z: 0, ry: Math.PI / 2 },
                    { x: -4.5, y: 0, z: 0, ry: Math.PI / 2 }
                ];
                tablePositions.forEach(pos => {
                    const table = new THREE.Mesh(BoxGeometry, BoxMaterial);
                    table.position.set(pos.x, pos.y, pos.z);
                    table.rotation.y = pos.ry;
                    table.castShadow = true;
                    sceneGraph.add(table);
                });

                // Create walls
                const restaurantWallsGeometry = new THREE.BoxGeometry(13, 4 ,15);
                const restaurantWallsTexture = textureLoader.load('textures/wall.jpg');
                restaurantWallsTexture.wrapS = THREE.RepeatWrapping;
                restaurantWallsTexture.wrapT = THREE.RepeatWrapping;
                restaurantWallsTexture.repeat.set(3, 2);
                const restaurantWallsMaterials = [
                    new THREE.MeshPhongMaterial({ map: restaurantWallsTexture, side: THREE.DoubleSide}), // right
                    new THREE.MeshPhongMaterial({ map: restaurantWallsTexture , side: THREE.DoubleSide}), // left
                    new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)' , transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide}), // top
                    new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)' }), // bottom
                    new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)' , transparent: true, opacity: 0}), // front
                    new THREE.MeshPhongMaterial({ map: restaurantWallsTexture, side: THREE.DoubleSide })  // back
                ];
                const restaurantWalls = new THREE.Mesh(restaurantWallsGeometry, restaurantWallsMaterials);
                restaurantWalls.castShadow = true;
                restaurantWalls.receiveShadow = true;
                
                sceneGraph.add(restaurantWalls);
                
                // Add door
                const doorTexture = textureLoader.load('textures/door.jpg');
                doorTexture.wrapS = THREE.RepeatWrapping;
                doorTexture.wrapT = THREE.RepeatWrapping;
                doorTexture.repeat.set(15,1);
                const doorGeometry = new THREE.BoxGeometry(8, 1.7, 0.2);
                const doorMaterial = new THREE.MeshPhongMaterial({ map: doorTexture, side: THREE.DoubleSide });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(0, 0.85,-7.5);
                door.castShadow = true;
                door.receiveShadow = true;
                sceneGraph.add(door);

                // Ilumination inside the restaurant
                let lightRNumber = 4;  
                const lightRSource = new THREE.PointLight('rgb(255, 255, 204)',10,10);
                lightRSource.decay = 2;
                lightRSource.castShadow = true;
                
                for(let i = 0; i < lightRNumber; i++){
                    const lightRClone = lightRSource.clone();
                    if(i == 0){
                        lightRClone.position.set(-3, 2, -3);
                    } else if(i == 1){
                        lightRClone.position.set(-3, 2, 3);
                    } else if(i == 2){
                        lightRClone.position.set(3, 2, -3);
                    } else if(i == 3){
                        lightRClone.position.set(3, 2, 3);
                    }
                    lightRClone.castShadow = true;
                    lightRClone.receiveShadow = true;
                    sceneGraph.add(lightRClone);
                }

                // Create bell
                const bellGroup = new THREE.Group();

                const buttonGeometry = new THREE.CylinderGeometry(0.2, 0.4, 0.1, 32);
                const buttonMaterial = new THREE.MeshPhongMaterial({ color: 'black' });
                const resetButton = new THREE.Mesh(buttonGeometry, buttonMaterial);

                const bellGeometry = new THREE.SphereGeometry(0.3,32,16, 0, Math.PI * 2, 0, Math.PI / 2);
                const bellMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,215,0)' });
                const bell = new THREE.Mesh(bellGeometry, bellMaterial);

                const topGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.1, 32);
                const topMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(160,160,160)' });
                const topButton = new THREE.Mesh(topGeometry, topMaterial);

                resetButton.position.set(0, 0, 0);
                bell.position.set(0, 0.1, 0);
                topButton.position.set(0, 0.4, 0);

                resetButton.name = "resetButton";
                resetButton.castShadow = true;
                bell.castShadow = true;
                topButton.castShadow = true;
                resetButton.receiveShadow = true;
                bell.receiveShadow = true;
                topButton.receiveShadow = true;

                bellGroup.add(resetButton, bell, topButton);
                bellGroup.position.set(-4.5, 0.4, 0);
                sceneGraph.add(bellGroup);

                ///////////////////////////////////////////////////////////////////////
                //  CREATE OUTSIDE SCENERY
                ///////////////////////////////////////////////////////////////////////
                
                // Create grass plane
                const grassTexture = textureLoader.load('textures/grass.jpg');
                grassTexture.wrapS = THREE.RepeatWrapping;
                grassTexture.wrapT = THREE.RepeatWrapping;
                grassTexture.repeat.set(5, 5);

                const grassGeometry = new THREE.BoxGeometry(60,60);
                const grassMaterial = new THREE.MeshPhongMaterial({map: grassTexture, side: THREE.DoubleSide});
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                sceneGraph.add(grass);

                grass.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
                grass.position.set(0,-0.7,0);
                grass.receiveShadow = true;

                // Create road plane
                const roadGeometry = new THREE.BoxGeometry(70,4);
                const roadMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(58,58,58)', side: THREE.DoubleSide });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                sceneGraph.add(road);

                road.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
                road.position.set(0,-0.5,-13);
                road.receiveShadow = true;
                
                // Add road stripe
                const roadstripeGeometry = new THREE.BoxGeometry(70,0.2);
                const roadstripeMaterial = new THREE.MeshPhongMaterial({ color: 'rgb(255,255,255)', side: THREE.DoubleSide });
                const roadstripe = new THREE.Mesh(roadstripeGeometry, roadstripeMaterial);
                const roadstripeL = new THREE.Mesh(roadstripeGeometry, roadstripeMaterial);
                const roadstripeR = new THREE.Mesh(roadstripeGeometry, roadstripeMaterial);
                sceneGraph.add(roadstripe,roadstripeL,roadstripeR);

                roadstripe.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
                roadstripe.position.set(0,-0.45,-15);
                roadstripeL.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
                roadstripeL.position.set(0,-0.45,-13);
                roadstripeR.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
                roadstripeR.position.set(0,-0.45,-11);

                // Add side walk
                const sideWalkTexture = textureLoader.load('textures/sidewalk.jpg');
                sideWalkTexture.wrapS = THREE.RepeatWrapping;
                sideWalkTexture.wrapT = THREE.RepeatWrapping;
                sideWalkTexture.repeat.set(10, 1);
                const sidewalkGeometry = new THREE.BoxGeometry(70,12,0.55);
                const sidewalkMaterial = new THREE.MeshPhongMaterial({ map: sideWalkTexture, side: THREE.DoubleSide });
                const sidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
                sceneGraph.add(sidewalk);
                sidewalk.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2);
                sidewalk.position.set(0,-0.45,-13);

                // Create lamp posts
                let numLamps = 6;
                const lampGroup = new THREE.Group();
                const postGeometry = new THREE.CylinderGeometry(0.2,0.2,6,32);
                const postMaterial = new THREE.MeshPhongMaterial({color: 'rgb(0,0,0)'});
                const post = new THREE.Mesh(postGeometry,postMaterial);
                post.castShadow = true;
                lampGroup.add(post);

                const lampCapGeomety = new THREE.SphereGeometry(0.5,32,16);
                const lampCapMaterial = new THREE.MeshPhongMaterial({color: 'rgb(255, 162, 57)', transparent: true, opacity: 0.7, emissive: 'rgb(255, 162, 57)', emissiveIntensity: 1});
                const lampCap = new THREE.Mesh(lampCapGeomety,lampCapMaterial);
                lampCap.position.set(0,3.4,0);
                lampGroup.add(lampCap);

                // Light coming from the lamp
                const lampLight = new THREE.PointLight('rgb(255, 162, 57)', 10, 10);
                lampLight.castShadow = true;
                lampLight.decay = 0.7;
                lampLight.position.set(0, 3, 0);
                lampGroup.add(lampLight);
                lampGroup.position.set(0,0,-10);
                lampGroup.castShadow = true;
                lampGroup.receiveShadow = true;
                lampGroup.receiveShadow = true;

                // Add multiple Lamps to the scene
                for(let i = 0; i < numLamps; i++){
                    const lampClone = lampGroup.clone();
                    lampClone.position.set(i*10-20,0,-10);  
                    sceneGraph.add(lampClone);
                }
            }
        };

        ///////////////////////////////////////////////////////////////////////
        // GENERATE NEW PIZZAS
        ///////////////////////////////////////////////////////////////////////
        function newPizzas() {
            pizzasA.forEach(pizza => {
                if (pizza) sceneElements.sceneGraph.remove(pizza);
            });
            pizzasA.length = 0;
            
            setTimeout(() => {
                for (let i = 0; i < 5; i++) {
                    createPizza(sceneElements.sceneGraph, i, false);
                }
            }, 250);
        }

        //////////////////////////////////////////////////////////////////////////
        // SPAWN CARS ON ROAD
        //////////////////////////////////////////////////////////////////////////

        // Initialize cars
        function initCars() {
            for (let i = 0; i < 2; i++) { // pick number of cars
                const lane = carLanes[i % carLanes.length];
                const direction = lane === -14 ? 1 : -1;
                const car = createCar(direction);
                car.position.set(direction === 1 ? -25 : 25, 0.25, lane);
                car.rotation.y = direction === -1 ? Math.PI : 0;
                car.userData = {
                    speed: carSpeedRange[0] + Math.random() * (carSpeedRange[1] - carSpeedRange[0]),
                    direction: direction,
                    lane: lane
                };
                sceneElements.sceneGraph.add(car);
                cars.push(car);
            }
        }
        
        setTimeout(initCars, 1000);
        
        // Animate cars on road
        function animateCars(deltaTime) {
            for (let i = 0; i < cars.length; i++) {
                const car = cars[i];
                car.position.x += car.userData.speed * car.userData.direction * deltaTime;

                if ((car.userData.direction === 1 && car.position.x > 27) ||
                    (car.userData.direction === -1 && car.position.x < -27)) {
                    // Lane and direction
                    const lane = carLanes[Math.floor(Math.random() * carLanes.length)];
                    const direction = lane === -14 ? 1 : -1;
                    car.position.set(direction === 1 ? -25 : 25, 0.25, lane);
                    car.rotation.y = direction === -1 ? Math.PI : 0;
                    car.userData.speed = carSpeedRange[0] + Math.random() * (carSpeedRange[1] - carSpeedRange[0]);
                    car.userData.direction = direction;
                    car.userData.lane = lane;
                }
            }
        }

        ///////////////////////////////////////////////////////////////////////
        // TIMER FUNCTIONALITY
        ///////////////////////////////////////////////////////////////////////

        // Function to start the timer
        function startTimer() {
            startTime = new Date().getTime();
            timerInterval = setInterval(function() {
                let currentTime = new Date().getTime();
                let timeDiff = currentTime - startTime;
                let seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);
                let minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                elapsedSeconds = Math.floor(timeDiff / 1000);
                document.getElementById("timer").innerHTML = minutes + "m " + seconds + "s ";
            }, 1000);
        }

        ///////////////////////////////////////////////////////////////////////
        // Game logic
        ///////////////////////////////////////////////////////////////////////

        // Handle kitten movement
        function handleKittenMovement(deltaTime) {
            const kitten = sceneElements.sceneGraph.getObjectByName("kitten");
            if (!kitten) return;

            const distance = kittenSpeed * deltaTime;

            if (keyD && kitten.position.x <= 3.5) {
                kitten.rotation.y = 0;
                kitten.translateX(distance);
            }
            if (keyW && kitten.position.z >= -4.5) {
                kitten.rotation.y = Math.PI / 2;
                kitten.translateX(distance);
            }
            if (keyA && kitten.position.x >= -3.5) {
                kitten.rotation.y = -Math.PI;
                kitten.translateX(distance);
            }
            if (keyS && kitten.position.z <= 4.5) {
                kitten.rotation.y = -Math.PI / 2;
                kitten.translateX(distance);
            }
        }

        // Update bounding boxes for kitten and held pizza
        function updateBoundingBoxes() {
            const kitten = sceneElements.sceneGraph.getObjectByName("kitten");

            if (kitten) {
                kittenBB.setFromObject(kitten);
                kittenBB.expandByScalar(0.2);
                // kittenHelper.updateMatrixWorld(true);
            }

            if (heldPizza && heldPizzaBB) {
                heldPizzaBB.setFromObject(heldPizza);
                heldPizzaBB.expandByScalar(0.2);
            }
        }

        // Handle pizza pickup and movement with kitten
        function handlePizzaWithKitten() {
            const kitten = sceneElements.sceneGraph.getObjectByName("kitten");
            if (!kitten) return;

            if (heldPizza) {
                const forward = new THREE.Vector3(1, 0.5, 0).applyQuaternion(kitten.quaternion).normalize();
                heldPizza.position.copy(kitten.position.clone().add(forward));
                if (heldPizzaBB) heldPizzaBB.setFromObject(heldPizza);
            }
        }

        // Handle pizza interaction with customer orders
        function handlePizzaWithCustomers() {
            // Check if the held pizza intersects with any customer pizzas
            if (heldPizza && heldPizzaBB) {
                for (let i = 0; i < pizzasCustomer.length; i++) {
                    const customerPizza = pizzasCustomer[i];
                    if (customerPizza) {
                        const customerPizzaBB = new THREE.Box3().setFromObject(customerPizza);
                        customerPizzaBB.expandByScalar(0.2);

                        if (heldPizzaBB.intersectsBox(customerPizzaBB)) {
                            // Check pizza type
                            if (heldPizza.userData.pizzaType === customerPizza.userData.pizzaType) {
                                console.log("Correct pizza delivered to customer " + i);
                                const respawnPosition = new THREE.Vector3(i * 1.5 - 3, 0.5, -5.8);
                                animateCustomerLeave(customers[i], i, respawnPosition);
                                score += 10;
                                updateScoreUI();
                                sceneElements.sceneGraph.remove(customerPizza);
                                pizzasCustomer[i] = null;
                                sceneElements.sceneGraph.remove(heldPizza);
                                pizzasA.splice(pizzasA.indexOf(heldPizza), 1);
                                console.log(pizzasCustomer);
                                console.log("Pizzas left: " + pizzasA.length);

                                heldPizza = null;
                                heldPizzaBB = null;
                                return;
                            } else {
                                console.log("Wrong pizza type");
                            }
                            break;
                        }
                    }
                }
            }
        }

        // Interaction with reset button
        function handleButtonInteraction() {
            const kitten = sceneElements.sceneGraph.getObjectByName("kitten");
            const button = sceneElements.sceneGraph.getObjectByName("resetButton");
            if (!kitten || !button || !kittenBB) return;

            const buttonBB = new THREE.Box3().setFromObject(button);
            buttonBB.expandByScalar(0.2);

            const now = performance.now();
            if (kittenBB.intersectsBox(buttonBB) && keyE && (now - lastButtonPress > 500)) {
                newPizzas();
                lastButtonPress = now;
            }
        }

        ///////////////////////////////////////////////////////////////////////
        // ANIMATION
        ///////////////////////////////////////////////////////////////////////

        // Animate customer leaving the restaurant
        function animateCustomerLeave(customer, index) {
            const startZ = customer.position.z;
            const endZ = -9;
            const duration = 1000;
            const startTimeAnim = performance.now();
            const respawnPosition = customer.position.clone();

            function animateWalk(now) {
                const elapsed = now - startTimeAnim;
                const t = Math.min(elapsed / duration, 1);
                customer.position.z = startZ + (endZ - startZ) * t;

                if (t < 1) {
                    requestAnimationFrame(animateWalk);
                } else {
                    sceneElements.sceneGraph.remove(customer);
                    customers[index] = null;
                    setTimeout(() => {
                        if (pizzasCustomer[index]) {
                            sceneElements.sceneGraph.remove(pizzasCustomer[index]);
                            pizzasCustomer[index] = null;
                        }
                        generateRandomCustomer(sceneElements.sceneGraph, index, respawnPosition);
                    }, 1000);
                }
            }
            requestAnimationFrame(animateWalk);
        }

        // Update the camera position following the kitten
        function updateCameraFollow() {
            const kitten = sceneElements.sceneGraph.getObjectByName("kitten");
            if (!kitten) return;

            const cameraPosition = kitten.position.clone().add(cameraOffset);
            sceneElements.camera.position.copy(cameraPosition);
            sceneElements.camera.lookAt(kitten.position);
        }

        // Update score UI
        function updateScoreUI() {
            document.getElementById("score").textContent = score;
        }

        ///////////////////////////////////////////////////////////////////////
        // Overlays
        ///////////////////////////////////////////////////////////////////////

        // Start buttom functionality
        window.addEventListener('DOMContentLoaded', () => {
            const startOverlay = document.getElementById('startOverlay');
            const startButton = document.getElementById('startButton');
            const elGatito = document.getElementById('ElGatitoPizzeria');
            const helpMenu = document.getElementById('helpMenu');
            const dataMenu = document.getElementById('dataMenu');
            const loadingScreen = document.getElementById('loadingScreen');

            startButton.addEventListener('click', () => {
                // Hide overlay
                startOverlay.style.display = 'none';
                elGatito.style.display = '';
                helpMenu.style.display = '';
                dataMenu.style.display = '';

                // Show loading screen
                loadingScreen.style.display = 'flex';
                scene.load3DObjects(sceneElements.sceneGraph);
                
                // Start game
                gameStart = true;
                startTimer();
            });
        });

        // GameOver Overlay
        function showGameOverOverlay() {
            let overlay = document.getElementById('gameOverOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'gameOverOverlay';
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100vw';
                overlay.style.height = '100vh';
                overlay.style.background = 'rgba(0,0,0,0.85)';
                overlay.style.display = 'flex';
                overlay.style.flexDirection = 'column';
                overlay.style.justifyContent = 'center';
                overlay.style.alignItems = 'center';
                overlay.style.zIndex = '1000';
                overlay.style.color = 'white';
                overlay.style.fontSize = '2.5em';
                overlay.style.fontFamily = 'Times New Roman';
                overlay.style.backgroundImage = "url('textures/background.jpg')";
                overlay.style.backgroundSize = 'cover';
                overlay.style.backgroundPosition = 'center';
                
                document.body.appendChild(overlay);
            }

            // Get time from timer
            const timerText = document.getElementById("timer").textContent;
            overlay.innerHTML = `
                <div style="background:rgba(30,30,30,0.95);padding:40px 60px;border-radius:20px;box-shadow:0 0 30px #000; display: flex; flex-direction: column; align-items: center;">
                    <h1 style="margin-bottom: 20px;">Your final score is:</h1>
                    <div style="margin-bottom: 15px;">Score: <b>${score}</b></div>
                    <div style="margin-bottom: 15px;">Time: <b>${timerText}</b></div>
                    <button onclick="location.reload()" style="margin-top: 30px; font-size: 1.2em; padding: 0.5em 1.5em; border-radius: 10px; cursor: pointer; background-color: #ffc107; border: 2px solid #e0a800; color: #402008; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        Restart Game
                    </button>
                </div>
            `;
        }

        function showNextHint() {
            const hintMenu = document.getElementById('hintMenu');
            if (hintMenu) {
                hintMenu.innerHTML = `<b>Hint:</b> ${hints[currentHintIndex]}`;
                currentHintIndex = (currentHintIndex + 1) % hints.length;
            }
        }

        // Cycle through hints
        window.addEventListener('DOMContentLoaded', () => {
            showNextHint();
            setInterval(showNextHint, 5000);
        });

        ///////////////////////////////////////////////////////////////////////
        // MAIN ANIMATION LOOP
        ///////////////////////////////////////////////////////////////////////
        function computeFrame(time) {
            let deltaTime = (time - lastTime) / 1000;
            deltaTime = Math.min(deltaTime, 0.05);    // cap DeltaTime
            lastTime = time;

            if (!gameEnded && (score >= 500 || elapsedSeconds >= 120)) {
                gameEnded = true;
                clearInterval(timerInterval);
                showGameOverOverlay();
            }
            
            updateScoreUI();
            handleKittenMovement(deltaTime);
            updateBoundingBoxes();
            handlePizzaWithKitten();
            handlePizzaWithCustomers();
            updateCameraFollow();
            handleButtonInteraction();
            animateCars(deltaTime);

            helper.render(sceneElements);
            if (sceneElements.control) sceneElements.control.update();

            requestAnimationFrame(computeFrame);
        }


        function init() {
            helper.initEmptyScene(sceneElements);
            // Preload customer model
            const customerLoader = new GLTFLoader();
            customerLoader.load(
                'Kitten.glb',
                function (gltf) {
                    customerGLTF = gltf.scene;
                },
                undefined,
                function (error) {
                    console.error('An error occurred while preloading the customer model:', error);
                }
            );
        }


        // HANDLING EVENTS

        // Event Listeners

        window.addEventListener('resize', resizeWindow);

        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);

        // Update render image size and camera aspect when the window is resized
        function resizeWindow(eventParam) {
            const width = window.innerWidth;
            const height = window.innerHeight;

            if (sceneElements.camera) {
                sceneElements.camera.aspect = width / height;
                sceneElements.camera.updateProjectionMatrix();
            }
            if (sceneElements.renderer) {
                sceneElements.renderer.setSize(width, height);
            }
        }

        function onDocumentKeyDown(event) {
            if(gameStart==false)return;
            switch (event.keyCode) {
                case 68: //d
                    keyD = true;
                    break;
                case 83: //s
                    keyS = true;
                    break;
                case 65: //a
                    keyA = true;
                    break;
                case 87: //w
                    keyW = true;
                    break;
                case 32: //space
                    if (!heldPizza) {
                        // Try to pick up a pizza
                        const kitten = sceneElements.sceneGraph.getObjectByName("kitten");
                        if (!kitten) return;
                        for (let i = 0; i < pizzasA.length; i++) {
                            const pizza = pizzasA[i];
                            if (pizza && kittenBB.intersectsBox(new THREE.Box3().setFromObject(pizza))) {
                                heldPizza = pizza;
                                heldPizzaBB = new THREE.Box3().setFromObject(heldPizza);
                                break;
                            }
                        }
                    } else {
                        // Drop pizza
                        heldPizza = null;
                        heldPizzaBB = null;
                    }
                    break;
                case 69: //e
                    keyE = true;
                    break;
            }
        }

        function onDocumentKeyUp(event) {
            if(gameStart==false)return;
            switch (event.keyCode) {
                case 68: //d
                    keyD = false;
                    break;
                case 83: //s
                    keyS = false;
                    break;
                case 65: //a
                    keyA = false;
                    break;
                case 87: //w
                    keyW = false;
                    break;
                case 69: //e
                    keyE = false;
                    break;
            }
        }

        // STARTING
        init();

    </script>

</head>

<body>
    <div id="loadingScreen" style="position: fixed; width: 100vw; height: 100vh; background-color: rgba(30,30,30,0.95); color: white; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 1001; font-size: 2.5em; text-align: center; font-family: 'Times New Roman', serif;">
        <div>Loading El Gatito Pizzeria...</div>
        <div id="loadingProgress" style="font-size: 0.8em; margin-top: 20px;">0%</div>
    </div>

    <div id="startOverlay" style="position: fixed; width: 100vw; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; background: url('textures/background.jpg') center center / cover no-repeat; z-index: 10; padding-top: 50px;">
        <img src="textures/el_gatito_pizzeria.jpg" alt="El Gatito Pizzeria" style="max-width: 80%; max-height: 300px; margin-bottom: 20px; border: 5px solid #503018; border-radius:10px;">
        <h1 style="color: white; font-size: 3em; font-family: 'Times New Roman'; text-shadow: 2px 2px 0 #000,-2px -2px 0 #000,2px -2px 0 #000,-2px 2px 0 #000, 0 0 10px #000; text-align: center;">
            Welcome to El Gatito Pizzeria!
        </h1>
        <button id="startButton" style="font-size: 2rem;margin-top: 40px;padding: 0.8em 1.8em;border-radius: 10px; cursor: pointer; background-color: #ffc107; border: 3px solid #e0a800; color: #402008; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
            Start Game
        </button>
    </div>
    <div id="ElGatitoPizzeria"> </div>
    <div id="helpMenu" style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.85); padding: 10px; border-radius: 8px; font-family: Arial, sans-serif; box-shadow: 0 2px 5px rgba(0,0,0,0.2); display:none;">
        <h3 style = "text-align: center;">Objective</h3>
        <h1 style="font-size: 1em; font-weight: normal; padding-left: 10px; padding-right: 10px;">Deliver the correct order of <br>pizza to the customers!</h1>
        <hr style="margin: 8px 0; border-color: rgba(0,0,0,0.1);">
        <h3 style="text-align: center;">Controls</h3>
        <ul style="list-style: circle; padding-left: 15px;">
            <li style="margin-bottom: 5px;"><b>Movement: </b>A,W,S,D </li>
            <li style="margin-bottom: 5px;"><b>PickUp/Drop: </b> SpaceBar</li>
            <li style="margin-bottom: 5px;"><b>Interact with bell: </b> E (New Pizzas)</li>
        </ul>
    </div>
    <div id="dataMenu" style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.85); padding: 15px; border-radius: 8px; font-family: Arial, sans-serif; box-shadow: 0 2px 5px rgba(0,0,0,0.2); text-align: right; display:none;">
        <div id="dataTable">
            <div style="margin-bottom: 8px; font-size: 1.8em;"><b>Score: <span id="score">0</span> </b></div>
            <hr style="margin: 8px 0; border-color: rgba(0,0,0,0.1);">
            <div style="font-size: 1.1em;"><b>Time: </b><span id="timer">0m 0s</span></div>
        </div>
    </div>
    <div id="hintMenu" style="position: fixed; left: 15px; bottom: 15px; background: rgba(255,255,200,0.92); color: #333; padding: 14px 22px; border-radius: 10px; font-family: Arial, sans-serif; font-size: 1.1em; box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 20;">
        <b>Hint:</b>
    </div>
</body>

</html>